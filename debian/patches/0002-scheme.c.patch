From: "Barak A. Pearlmutter" <barak+git@cs.nuim.ie>
Date: Mon, 18 Feb 2013 09:00:48 +0000
Subject: scheme.c

---
 scheme.c | 98 +++++++++++++++++++++++++++++++++++++++++++++++++++++-----------
 1 file changed, 81 insertions(+), 17 deletions(-)

diff --git a/scheme.c b/scheme.c
index 744edc7..ee761a0 100644
--- a/scheme.c
+++ b/scheme.c
@@ -161,6 +161,7 @@ INTERFACE INLINE int is_string(pointer p)     { return (type(p)==T_STRING); }
 #define strvalue(p)      ((p)->_object._string._svalue)
 #define strlength(p)        ((p)->_object._string._length)
 
+INTERFACE static int is_list(scheme *sc, pointer p);
 INTERFACE INLINE int is_vector(pointer p)    { return (type(p)==T_VECTOR); }
 INTERFACE static void fill_vector(pointer vec, pointer obj);
 INTERFACE static pointer vector_elem(pointer vec, int ielem);
@@ -926,7 +927,8 @@ static pointer mk_empty_string(scheme *sc, int len, char fill) {
 }
 
 INTERFACE static pointer mk_vector(scheme *sc, int len) {
-     pointer x=get_consecutive_cells(sc,len/2+len%2+1);
+     pointer x=get_consecutive_cells(sc,len/2+len%2+1);
+     if(sc->no_memory) { return sc->sink; }
      typeflag(x) = (T_VECTOR | T_ATOM);
      ivalue_unchecked(x)=len;
      set_integer(x);
@@ -2485,7 +2487,11 @@ static pointer opexe_0(scheme *sc, enum scheme_opcodes op) {
 
      case OP_LET1:       /* let (calculate parameters) */
           sc->args = cons(sc, sc->value, sc->args);
-          if (is_pair(sc->code)) { /* continue */
+          if (is_pair(sc->code)) { /* continue */
+               if (!is_pair(car(sc->code)) || !is_pair(cdar(sc->code))) {
+                    Error_1(sc, "Bad syntax of binding spec in let :",
+                            car(sc->code));
+               }
                s_save(sc,OP_LET1, sc->args, cdr(sc->code));
                sc->code = cadar(sc->code);
                sc->args = sc->NIL;
@@ -2504,8 +2510,11 @@ static pointer opexe_0(scheme *sc, enum scheme_opcodes op) {
                new_slot_in_env(sc, caar(x), car(y)); 
           }
           if (is_symbol(car(sc->code))) {    /* named let */
-               for (x = cadr(sc->code), sc->args = sc->NIL; x != sc->NIL; x = cdr(x)) {
-
+               for (x = cadr(sc->code), sc->args = sc->NIL; x != sc->NIL; x = cdr(x)) {
+                    if (!is_pair(x))
+                        Error_1(sc, "Bad syntax of binding in let :", x);
+                    if (!is_list(sc, car(x)))
+                        Error_1(sc, "Bad syntax of binding in let :", car(x));
                     sc->args = cons(sc, caar(x), sc->args);
                }
                x = mk_closure(sc, cons(sc, reverse_in_place(sc, sc->NIL, sc->args), cddr(sc->code)), sc->envir); 
@@ -2565,7 +2574,11 @@ static pointer opexe_1(scheme *sc, enum scheme_opcodes op) {
 
      case OP_LET1REC:    /* letrec (calculate parameters) */
           sc->args = cons(sc, sc->value, sc->args);
-          if (is_pair(sc->code)) { /* continue */
+          if (is_pair(sc->code)) { /* continue */
+               if (!is_pair(car(sc->code)) || !is_pair(cdar(sc->code))) {
+                    Error_1(sc, "Bad syntax of binding spec in letrec :",
+                            car(sc->code));
+               }
                s_save(sc,OP_LET1REC, sc->args, cdr(sc->code));
                sc->code = cadar(sc->code);
                sc->args = sc->NIL;
@@ -3119,6 +3132,7 @@ static pointer opexe_2(scheme *sc, enum scheme_opcodes op) {
                Error_1(sc,"vector: not a proper list:",sc->args);
           }
           vec=mk_vector(sc,len);
+          if(sc->no_memory) { s_return(sc, sc->sink); }
           for (x = sc->args, i = 0; is_pair(x); x = cdr(x), i++) {
                set_vector_elem(vec,i,car(x));
           }
@@ -3135,7 +3149,8 @@ static pointer opexe_2(scheme *sc, enum scheme_opcodes op) {
           if(cdr(sc->args)!=sc->NIL) {
                fill=cadr(sc->args);
           }
-          vec=mk_vector(sc,len);
+          vec=mk_vector(sc,len);
+          if(sc->no_memory) { s_return(sc, sc->sink); }
           if(fill!=sc->NIL) {
                fill_vector(vec,fill);
           }
@@ -3179,17 +3194,64 @@ static pointer opexe_2(scheme *sc, enum scheme_opcodes op) {
      }
      return sc->T;
 }
+
+static int is_list(scheme *sc, pointer a) {
+    pointer slow, fast;
+
+    slow = fast = a;
+    while (1)
+    {
+        if (fast == sc->NIL)
+                return 1;
+        if (!is_pair(fast))
+                return 0;
+        fast = cdr(fast);
+        if (fast == sc->NIL)
+                return 1;
+        if (!is_pair(fast))
+                return 0;
+        fast = cdr(fast);
+
+        slow = cdr(slow);
+        if (fast == slow)
+        {
+            /* the fast pointer has looped back around and caught up
+               with the slow pointer, hence the structure is circular,
+               not of finite length, and therefore not a list */
+            return 0;
+        }
+    }
+}
 
 static int list_length(scheme *sc, pointer a) {
-     int v=0;
-     pointer x;
-     for (x = a, v = 0; is_pair(x); x = cdr(x)) {
-          ++v;
-     }
-     if(x==sc->NIL) {
-          return v;
-     }
-     return -1;
+    int i=0;
+    pointer slow, fast;
+
+    slow = fast = a;
+    while (1)
+    {
+        if (fast == sc->NIL)
+                return i;
+        if (!is_pair(fast))
+                return i;
+        fast = cdr(fast);
+        ++i;
+        if (fast == sc->NIL)
+                return i;
+        if (!is_pair(fast))
+                return i;
+        ++i;
+        fast = cdr(fast);
+
+        slow = cdr(slow);
+        if (fast == slow)
+        {
+            /* the fast pointer has looped back around and caught up
+               with the slow pointer, hence the structure is circular,
+               not of finite length, and therefore not a list */
+            return -1;
+        }
+    }
 }
 
 static pointer opexe_3(scheme *sc, enum scheme_opcodes op) {
@@ -4116,8 +4178,10 @@ static struct scheme_interface vtbl ={
   is_integer,
   is_real,
   is_character,
-  charvalue,
-  is_vector,
+  charvalue,
+  is_list,
+  is_vector,
+  list_length,
   ivalue,
   fill_vector,
   vector_elem,
